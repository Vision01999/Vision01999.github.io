(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{514:function(t,e,s){"use strict";s.r(e);var o=s(6),n=Object(o.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue3"}},[t._v("#")]),t._v(" Vue3")]),t._v(" "),s("h2",{attrs:{id:"definecomponent"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#definecomponent"}},[t._v("#")]),t._v(" defineComponent")]),t._v(" "),s("ul",[s("li"),t._v(" "),s("li",[t._v("引入 defineComponent() 以正确推断 setup() 组件的参数类型")]),t._v(" "),s("li",[t._v("defineComponent 可以正确适配无 props、数组 props 等形式")]),t._v(" "),s("li",[t._v("defineComponent 可以接受显式的自定义 props 接口或从属性验证对象中自动推断")])]),t._v(" "),s("h2",{attrs:{id:"setup"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setup"}},[t._v("#")]),t._v(" Setup（）")]),t._v(" "),s("p",[t._v("setup函数是处于 围绕 beforeCreate 和 created 生命周期钩子运行 也就说在 setup函数中是无法 使用 data 和 methods 中的数据和方法的")]),t._v(" "),s("p",[t._v("setup函数是 Composition API（组合API）的入口")]),t._v(" "),s("p",[t._v("在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用")]),t._v(" "),s("p",[t._v("setup函数只能是同步的不能是异步的")]),t._v(" "),s("h3",{attrs:{id:"setup-中的props"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setup-中的props"}},[t._v("#")]),t._v(" Setup 中的props")]),t._v(" "),s("p",[t._v("props是一个对象，包含父组件传递给子组件的所有数据。 在子组件中使用props进行接收。 包含配置声明并传入的所有的属性的对象")]),t._v(" "),s("blockquote",[s("p",[t._v("就是一个数据拦截，先在子组件定义props 对象的类型，然后才能在setup 中的props中调用父组件传过来的值")])]),t._v(" "),s("h3",{attrs:{id:"setup-中的context"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setup-中的context"}},[t._v("#")]),t._v(" Setup 中的context")]),t._v(" "),s("p",[t._v("context 是一个对象")]),t._v(" "),s("p",[t._v("context.emit事件传递给父组件")]),t._v(" "),s("p",[t._v("有slots插槽")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('export default {\n  setup(props, context) {\n    // Attribute (非响应式对象，等同于 $attrs)\n    console.log(context.attrs)\n\t//未被father接收的值就可以通过v-bind="$attrs"传递给grandson了\n    // 插槽 (非响应式对象，等同于 $slots)\n    console.log(context.slots)\n\n    // 触发事件 (方法，等同于 $emit)\n    console.log(context.emit)\n\n    // 暴露公共 property (函数)\n    console.log(context.expose)\n  }\n}\n')])])]),s("p",[t._v("当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定，并且可以通过 "),s("code",[t._v('vbind="$attrs"')]),t._v("传入内部组件")]),t._v(" "),s("p",[t._v('父组件的 setup 返回的数据在模板通过 v-bind ： 绑定，且子组件没有props 接受，那么就可以 在 子组件的模板 孙组件的 标签上通过 v-bind ="$attrs" 来把 父组件的 setup返回的数据在 孙组件的 通过'),s("code",[t._v("{ {父组件的data key }}")]),t._v("来显示 值")])])}),[],!1,null,null,null);e.default=n.exports}}]);